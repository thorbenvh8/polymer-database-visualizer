<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="elements/database-schema.html">
<link rel="import" href="elements/database-minimap.html">

<!--
An element providing a solution to no problem in particular.

Example:

    <database-visualizer></database-visualizer>

@demo
-->
<dom-module id="database-visualizer">

    <style>
        :host {
            overflow: hidden;
            font-family: 'Roboto', 'Noto', sans-serif;
            display: block;
            box-sizing: content-box;
            height: 100%;
            background-color: #ECECEC;
            cursor: -webkit-grab;

            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        h1 {
            color: #DCDCDC;
            padding: 15px;
            margin: 0;
            position: absolute;
            bottom: 0px;
            right: 0px;

            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none;   /* Chrome/Safari/Opera */
            -khtml-user-select: none;    /* Konqueror */
            -moz-user-select: none;      /* Firefox */
            -ms-user-select: none;       /* Internet Explorer/Edge */
            user-select: none;           /* Non-prefixed version, currently
                                  not supported by any browser */
        }

        #canvas {
            position: absolute;
            cursor: -webkit-grab;
            font-size: 14px;
            line-height: 20px;
            overflow-x: visible;
            overflow-y: visible;
            width: 50px;
            height: 50px;
        }

        #loading {
            background: rgba(255,255,255,0.5);
            height: 100%;
            width: 100%;
            position: absolute;
            left: 0px;
            top: 0px;
            z-index: 92;
        }
        #loading.hidden {
            visibility: hidden;
        }
        #loading paper-spinner-lite {
            position: absolute !important;
            left: 50%;
            top: 50%;
            margin-left: -14px;
            margin-top: -14px;
        }

        paper-spinner-lite {
            --paper-spinner-color: var(--database-visualizer-database-spinner-color, --accent-color);
        }

    </style>

    <template>
        <h1>&lt;database-visualizer&gt;</h1>
        <div id="loading" class="loading hidden">
            <paper-spinner-lite active></paper-spinner-lite>
        </div>
        <database-minimap id="minimap"></database-minimap>
        <div id="canvas" class="database-visualizer-canvas" style="left: 0px; top: 0px;">
            <template is="dom-repeat" items="{{database.schemas}}">
                <database-schema id="{{item.name}}" schema="{{item}}"></database-schema>
            </template>
            <div id="storage" class="database-constraints-storage"></div>
        </div>
    </template>

</dom-module>

<script>
    // TODO add testing with nightwatch.js (www.nightwatchjs.org)
    // TODO screenshot gatlin

    // TODO tryout dc/os

    Polymer({

        is: 'database-visualizer',
        listeners: {
            'tap': '_handleTap',
            'track': '_handleTrack',
            'mousewheel': '_handleMousewheel'
        },
        properties: {
            translate: {
                type: Object,
                value: {
                    x: 0,
                    y: 0
                },
                observer: '_observerTranslate'
            },
            scale: {
                type: Number,
                value: 1,
                observer: '_observerScale'
            },
            transformOrigin: {
                type: Object,
                value: {
                    x: 0,
                    y: 0
                },
                observer: '_observerTransformOrigin'
            },
            database: {
                type: Object,
                notify: true,
                value: function () {
                    return {
                        schemas: [{
                            name: "schema1",
                            tables: [{name: "table1"}]
                        }],
                        foreignKeys: [{column: "column1"}]
                    };
                },
                observer: '_observerDatabase'
            },

            schemas: {
                type: Array,
                notify: true,
                value: function () {
                    return [];
                }
            }
        },
        scaleTranslate3d: function () {
            var scale = this.getScale();
            var x = this.translate.x + 'px';
            var y = this.translate.y + 'px';
            var z = '0px';
            var node = this.$.canvas;
            this.transform('scale(' + scale + ')' + 'translate3d(' + x + ',' + y + ',' + z + ')', node);
        },

        _observerTranslate() {
            this.scaleTranslate3d();
        },
        _observerScale() {
            this.scaleTranslate3d();
        },
        _observerTransformOrigin(transformOrigin) {
            var node = this.$.canvas;
            node.style.transformOrigin = transformOrigin.x + 'px ' + transformOrigin.y + 'px';
        },

        _onTap: function () {
            Array.prototype.slice.call(document.querySelectorAll('database-constraint-line')).forEach(function (databaseConstraintLine) {
                databaseConstraintLine.deselect();
            });
        },
        _handleTap: function (e) {
            if (e.target === this) {
                this._onTap();
            }
        },

        _handleTrack: function (e) {
            if (e.target === this) {
                this.track(e);
            }
        },

        _handleMousewheel: function (e) {
            // cross-browser wheel delta
            e = window.event || e; // old IE support
            var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));

            e.preventDefault();

            if (delta !== 0) {
                // find current location on screen
                var screen = {
                    x: event.pageX - this.offsetLeft,
                    y: event.pageY - this.offsetTop
                };

                // find current location on the image at the current scale
                this.transformOrigin = {
                    x: this.transformOrigin.x + ((screen.x - this._last.x) / this.getScale()),
                    y: this.transformOrigin.y + ((screen.y - this._last.y) / this.getScale())
                };

                // determine the new scale
                var rate = 30;
                var scale = this.getScale() * (1 + delta / rate);
                if (scale < 0.05) {
                    scale = 0.05;
                } else if (scale > 3) {
                    scale = 3;
                }

                // determine the location on the screen at the new scale
                this.translate = {
                    x: (screen.x - this.transformOrigin.x) / scale + this._move.x,
                    y: (screen.y - this.transformOrigin.y) / scale + this._move.y
                };

                this.setScale(scale);

                // save the current screen location
                this._last = screen;

                this.refreshMinimapZoom();
            }
        },

        track: function (e) {
            switch (e.detail.state) {
                case 'start':
                    this.style.pointerEvents = 'none';

                    this._track = {
                        x: this.translate.x,
                        y: this.translate.y
                    };
                    this.translate = {
                        x: this._track.x + e.detail.dx / this.getScale(),
                        y: this._track.y + e.detail.dy / this.getScale()
                    };
                    break;
                case 'track':
                    this.translate = {
                        x: this._track.x + e.detail.dx / this.getScale(),
                        y: this._track.y + e.detail.dy / this.getScale()
                    };
                    break;
                case 'end':
                    this.style.pointerEvents = '';

                    this.translate = {
                        x: this._track.x + e.detail.dx / this.getScale(),
                        y: this._track.y + e.detail.dy / this.getScale()
                    };

                    this._move = {
                        x: this._move.x + this.translate.x - this._track.x,
                        y: this._move.y + this.translate.y - this._track.y
                    };
                    break;
            }

            this.refreshMinimapZoom();
        },

        _observerDatabase() {
            this.schemas = [];

            this.scale = 1;

            this._move = {
                x: 0,
                y: 0
            };

            this.transformOrigin = {
                x: 0,
                y: 0
            };

            this._last = {
                x: 0,
                y: 0
            };


            this.$.minimap.classList.add('hidden');
            Array.prototype.slice.call(document.querySelectorAll('database-constraint-line')).forEach(function (databaseConstraintLine) {
                databaseConstraintLine.remove();
            });
        },

        getSchemas() {
            return this.schemas;
        },
        registerSchema(schema) {
            this.getSchemas().push(schema);

            if (this.database.schemas.length === this.getSchemas().length) {
                var mostLeft = null;
                var mostRight = null;
                var mostTop = null;
                var mostBottom = null;
                var mostLeftOffset = null;
                var mostTopOffset = null;
                this.getSchemas().forEach(function (schema) {
                    if (mostLeft === null || mostLeft > schema.getLeft()) {
                        mostLeft = schema.getLeft();
                    }
                    if (mostTop === null || mostTop > schema.getTop()) {
                        mostTop = schema.getTop();
                    }
                    if (mostRight === null || mostRight < schema.getLeft() + schema.getWidth()) {
                        mostRight = schema.getLeft() + schema.getWidth();
                    }
                    if (mostBottom === null || mostBottom < schema.getTop() + schema.getHeight()) {
                        mostBottom = schema.getTop() + schema.getHeight();
                    }
                    if (mostLeftOffset === null || mostLeftOffset > schema.translate.x) {
                        mostLeftOffset = schema.translate.x;
                    }
                    if (mostTopOffset === null || mostTopOffset > schema.translate.y) {
                        mostTopOffset = schema.translate.y;
                    }
                });
                var width = mostRight - mostLeft;
                var height = mostBottom - mostTop;
                var widthRatio = this.offsetWidth / width - 0.05;
                var heightRatio = this.offsetHeight / height - 0.05;

                this.setScale(widthRatio < heightRatio ? widthRatio : heightRatio);

                this.translate = {
                    x: (this.offsetWidth / this.getScale() - width) / 2 - mostLeftOffset,
                    y: (this.offsetHeight / this.getScale() - height) / 2 - mostTopOffset
                };

                this._move = this.translate;

                this.transformOrigin = {
                    x: 0,
                    y: 0
                };

                this.refresh();
                this.refreshMinimap();
                this.refreshMinimapZoom();
                this.$.loading.classList.add('hidden');
                this.$.minimap.classList.remove('hidden');
            }
        },

        getScale() {
            return this.scale;
        },

        setScale(scale) {
            return this.scale = scale;
        },

        setMinimapWidth(minimapWidth) {
            this.$.minimap.setMinimapWidth(minimapWidth);
        },
        getMinimapWidth() {
            this.$.minimap.getMinimapWidth();
        },
        setMinimapHeight(minimapHeight) {
            this.$.minimap.setMinimapHeight(minimapHeight);
        },
        getMinimapHeight() {
            this.$.minimap.getMinimapHeight();
        },

        refreshMinimapZoom() {
            this.$.minimap.refreshMinimapZoom();
        },

        refreshMinimap() {
            this.$.minimap.refreshMinimap();
        },

        refresh() {
            this.getSchemas().forEach(function (schema) {
                schema.refresh();
            });
        },

        fireUpdateTable(dvTableId, left, top) {
            this.fire('updateTable', {
                dvTableId,
                left,
                top
            });
        },

        fireUpdateSchema(dvSchemaId, left, top, width, height) {
            this.fire('updateSchema', {
                dvSchemaId,
                left,
                top,
                width,
                height
            });
        },

        fireUpdateConstraint(dvConstraintId, isConnectorLeft, isConnectorLeftRef, positions) {
            this.fire('updateConstraint', {
                dvConstraintId,
                isConnectorLeft,
                isConnectorLeftRef,
                positions
            });
        },

        // Element Lifecycle

        ready: function () {
            // `ready` is called after all elements have been configured, but
            // propagates bottom-up. This element's children are ready, but parents
            // are not.
            //
            // This is the point where you should make modifications to the DOM (when
            // necessary), or kick off any processes the element wants to perform.
        },

        attached: function () {
            // `attached` fires once the element and its parents have been inserted
            // into a document.
            //
            // This is a good place to perform any work related to your element's
            // visual state or active behavior (measuring sizes, beginning animations,
            // loading resources, etc).

        },


        detached: function () {
            // The analog to `attached`, `detached` fires when the element has been
            // removed from a document.
            //
            // Use this to clean up anything you did in `attached`.
        }

    });

</script>