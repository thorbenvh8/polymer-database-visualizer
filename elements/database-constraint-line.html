<!DOCTYPE html>
<html>
<head>
    <!-- Element Imports -->

    <link rel="import" href="../../paper-fab/paper-fab.html">
    <link rel="import" href="../../iron-icons/iron-icons.html">
    <link rel="import" href="database-constraint-line-button.html">
</head>

<dom-module id="database-constraint-line">
    <style>
        /* CSS rules for your element */
        :host {
            cursor: pointer;
        }

        :host database-constraint-line-button {
            visibility: hidden;
        }

        :host.selected-constraint database-constraint-line-button {
            visibility: visible;
        }

        :host.selected-constraint > svg path.line {
            stroke: var(--database-constraint-line-selected-stroke, --light-accent-color);
        }

        :host > svg path {
            fill: none;
        }

        :host > svg path.line {
            stroke: #000000;
            stroke-width: 2px;
        }
        :host > svg path.transparent-outline {
            stroke: transparent;
            stroke-width: 20px;
        }

        :host.highlight > svg,
        :host.selected-constraint > svg {
            z-index: 1;
        }

        :host.highlight > svg path.line {
            stroke: var(--database-constraint-line-highlighted-stroke, --light-accent-color);
            stroke-width: 4;
        }

        svg {
            overflow: visible;
            left: 0;
            top: 0;
            width: 1px;
            height: 1px;
            position: absolute;
        }
    </style>
    <template>
        <svg class="path-svg">
            <path class="transparent-outline" d=""></path>
            <path class="line" d=""></path>
        </svg>
    </template>
</dom-module>
<script>
    Polymer({
        is: "database-constraint-line",
        listeners: {
            'tap': '_handleTap',
            'mouseover': '_handleMouseover',
            'mouseout': '_handleMouseout'
        },
        properties: {
            constraint: {
                type: Object,
                notify: true,
                value: function () {
                    return {
                        name: "name",
                        schema: "schema1",
                        table: "table1",
                        columns: ["column1"],
                        rschema: "schema1",
                        rtable: "table2",
                        rcolumns: ["column1"],
                        positions: []
                    };
                },
                observer: '_observerConstraint'
            },
            highlighted: {
                type: Boolean,
                value: false,
                observer: '_observerHighlighted'
            },
            selected: {
                type: Boolean,
                value: false,
                observer: "_observerSelected"
            }
        },

        _observerConstraint(constraint) {
            this.classList.add(constraint.name);
        },
        _observerSelected(selected) {
            if (selected) {
                this.classList.add('selected-constraint');

                Array.prototype.slice.call(document.querySelectorAll('database-constraint-line')).forEach(function(databaseConstraintLine) {
                    if (this !== databaseConstraintLine) {
                        databaseConstraintLine.deselect();
                    }
                }, this);

                if (typeof this._table !== 'undefined' && typeof this._table.columns !== 'undefined') {
                    this._table.columns[0].constraintSelected(this._table.connector, this, "table");
                }
                if (typeof this._rTable !== 'undefined' && typeof this._rTable.columns !== 'undefined') {
                    this._rTable.columns[0].constraintSelected(this._rTable.connector, this, "rTable");
                }
            } else {
                this.classList.remove('selected-constraint');

                if (typeof this._table !== 'undefined' && typeof this._table.columns !== 'undefined') {
                    this._table.columns[0].constraintDeselected();
                }
                if (typeof this._rTable !== 'undefined' && typeof this._rTable.columns !== 'undefined') {
                    this._rTable.columns[0].constraintDeselected();
                }
            }
        },
        _observerHighlighted(highlighted) {
            if (highlighted) {
                this.classList.add('highlight');

                if (typeof this._table !== 'undefined' && typeof this._table.columns !== 'undefined') {
                    this._table.columns.forEach(function (column) {
                        column.classList.add('highlight');
                    });
                }
                if (typeof this._rTable !== 'undefined' && typeof this._rTable.columns !== 'undefined') {
                    this._rTable.columns.forEach(function (column) {
                        column.classList.add('highlight');
                    });
                }
            } else {
                this.classList.remove('highlight');

                if (typeof this._table !== 'undefined' && typeof this._table.columns !== 'undefined') {
                    this._table.columns.forEach(function (column) {
                        column.classList.remove('highlight');
                    });
                }
                if (typeof this._rTable !== 'undefined' && typeof this._rTable.columns !== 'undefined') {
                    this._rTable.columns.forEach(function (column) {
                        column.classList.remove('highlight');
                    });
                }
            }
        },

        _handleTap: function () {
            this.select();
        },

        _handleMouseover: function () {
            this.highlight();
        },
        _handleMouseout: function () {
            this.dehighlight();
        },

        ready: function () {

        },

        attached: function () {
            this._points = [];
            if (typeof this.constraint.positions !== 'undefined') {
                this.constraint.positions.forEach(function (position) {
                    this._drawPoint(position.position);
                }, this);
            }

            /** init tables **/
            this._table = {
                table: null,
                columns: [],
                column_pos: null,
                column_height: null,
                connector: ""
            };
            this._rTable = {
                table: null,
                columns: [],
                column_pos: null,
                column_height: null,
                connector: ""
            };

            /** save table **/
            this._table.table = document.querySelector('database-table#' + this.constraint.schema + "_" + this.constraint.table);
            this._table.table.registerConstraint(this);

            this.async(function() {
                this.refresh();
            });
        },

        getScale() {
            return this._table.table.getScale();
        },

        refreshConnector() {
            if (this._points.length === 0) {
                this._table.connector = "";
                this._rTable.connector = "";
            }
        },
        refresh() {
            /** save rTable **/
            if (this._rTable.table === null) {
                this._rTable.table = document.querySelector('database-table#' + this.constraint.rschema + "_" + this.constraint.rtable);
                this._rTable.table.registerConstraint(this);
            }

            let tablePos = this._table.table.getPosition();
            let rTablePos = this._rTable.table.getPosition();


            if (this._table.connector === "" && this._rTable.connector === "") {
                /** table <-> rTable **/
                if (tablePos.left < rTablePos.left) {
                    this._table.connector = "left";
                    this._rTable.connector = "right";
                }
                /** rTable <-> table **/
                else {
                    this._rTable.connector = "left";
                    this._table.connector = "right";
                }
            }

            this.refreshPath();
        },

        refreshPath() {
            Polymer.dom(this.root).children.forEach(function (el) {
                if (el.localName === 'database-constraint-line-button' && el.new) {
                    el.remove();
                }
            }, this);

            let tablePos = this._table.table.getPosition();
//            tablePos.left += 20;
//            tablePos.width += -40;
            let rTablePos = this._rTable.table.getPosition();
//            rTablePos.left += 20;
//            rTablePos.width += -40;

            // TODO calculate each time individual?!
            let diffX = this._table.column_height * 8 / 3;
            let diffY = this._table.column_height * 4 / 5;
            let diffBroomX = this._table.column_height * 5 / 3;

            let pathRPos;
            let d;
            if (this._rTable.connector === "left") {
                pathRPos = this._getRTablePathRPosLeft(rTablePos, diffX);
                d = this._getRTableDLeft(pathRPos, rTablePos, diffY, diffBroomX);
            }
            if (this._rTable.connector === "right") {
                pathRPos = this._getRTablePathRPosRight(rTablePos, diffX);
                d = this._getRTableDRight(pathRPos, rTablePos, diffY, diffBroomX);
            }

            let lastPoint = pathRPos;
            this._points.forEach(function(point) {
                let p = {
                    x: point.translate.x,
                    y: point.translate.y
                };
                d = d + " L " + p.x + " " + p.y;

                this._drawMiddlePoint(lastPoint, p, this._points.indexOf(point));

                lastPoint = p;
            }, this);

            let pathPos;
            if (this._table.connector === "left") {
                pathPos = this._getTablePathPosLeft(tablePos, diffX);
                d = d + this._getTableDLeft(pathPos, tablePos);
            }
            if (this._table.connector === "right") {
                pathPos = this._getTablePathPosRight(tablePos, diffX);
                d = d + this._getTableDRight(pathPos, tablePos);
            }

            this._drawMiddlePoint(lastPoint, pathPos, this._points.length);

            this.$$('path.transparent-outline').setAttribute('d', d);
            this.$$('path.line').setAttribute('d', d);
        },

        trackStartSchema() {
            this._points.forEach(function(point) {
                point.trackStartSchema();
            });
        },
        refreshPoints(diffPoint) {
            this._points.forEach(function(point) {
                point.translate = {
                    x: point.translate.x + diffPoint.x,
                    y: point.translate.y + diffPoint.y
                }
            });
        },

        _getRTablePathRPosRight(rTablePos, diffX) {
            return {
                x: (rTablePos.left - diffX),
                y: (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height)
            };
        },
        _getRTablePathRPosLeft(rTablePos, diffX) {
            return {
                x: (rTablePos.left + rTablePos.width + diffX),
                y: (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height)
            };
        },
        _getTablePathPosLeft(tablePos, diffX) {
            return {
                x: (tablePos.left + tablePos.width + diffX),
                y: (tablePos.top + this._table.column_pos.top + this._table.column_height)
            };
        },
        _getTablePathPosRight(tablePos, diffX) {
            return {
                x: (tablePos.left - diffX),
                y: (tablePos.top + this._table.column_pos.top + this._table.column_height)
            };
        },
        _getRTableDRight(pathRPos, rTablePos, diffY, diffBroomX) {
            let d = "M " + (rTablePos.left) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height + diffY);
            d = d + " L " + (rTablePos.left - 1) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height + diffY);
            d = d + " L " + (rTablePos.left - diffBroomX) + " " + (rTablePos.top + this._rTable.column_pos.top + this._table.column_height);
            d = d + " L " + (rTablePos.left - 1) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height - diffY);
            d = d + " L " + (rTablePos.left) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height - diffY);
            d = d + " L " + (rTablePos.left - 1) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height - diffY);
            d = d + " L " + (rTablePos.left - diffBroomX) + " " + (rTablePos.top + this._rTable.column_pos.top + this._table.column_height);
            d = d + " L " + (rTablePos.left) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height);
            d = d + " L " + pathRPos.x + " " + pathRPos.y;
            return d;
        },
        _getRTableDLeft(pathRPos, rTablePos, diffY, diffBroomX) {
            let d = "M " + (rTablePos.left + rTablePos.width) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height + diffY);
            d = d + " L " + (rTablePos.left + rTablePos.width + 1) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height + diffY);
            d = d + " L " + (rTablePos.left + rTablePos.width + diffBroomX) + " " + (rTablePos.top + this._rTable.column_pos.top + this._table.column_height);
            d = d + " L " + (rTablePos.left + rTablePos.width + 1) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height - diffY);
            d = d + " L " + (rTablePos.left + rTablePos.width) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height - diffY);
            d = d + " L " + (rTablePos.left + rTablePos.width + 1) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height - diffY);
            d = d + " L " + (rTablePos.left + rTablePos.width + diffBroomX) + " " + (rTablePos.top + this._rTable.column_pos.top + this._table.column_height);
            d = d + " L " + (rTablePos.left + rTablePos.width) + " " + (rTablePos.top + this._rTable.column_pos.top + this._rTable.column_height);
            d = d + " L " + pathRPos.x + " " + pathRPos.y;
            return d;
        },
        _getTableDLeft(pathPos, tablePos) {
            let d = " L " + pathPos.x + " " + pathPos.y;
            d = d + " L " + (tablePos.left + tablePos.width) + " " + (tablePos.top + this._table.column_pos.top + this._table.column_height);
            return d;
        },
        _getTableDRight(pathPos, tablePos) {
            let d = " L " + pathPos.x + " " + pathPos.y;
            d = d + " L " + (tablePos.left) + " " + (tablePos.top + this._table.column_pos.top + this._table.column_height);
            return d;
        },

        _drawMiddlePoint(point1, point2, index) {
            let point = {
                x: (point1.x + (point2.x - point1.x) / 2),
                y: (point1.y + (point2.y - point1.y) / 2)
            };

            let databaseConstraintLineButton = document.createElement('database-constraint-line-button');
            databaseConstraintLineButton.translate = {
                x: point.x,
                y: point.y
            };
            databaseConstraintLineButton.new = true;
            databaseConstraintLineButton.index = index;
            Polymer.dom(this.root).appendChild(databaseConstraintLineButton);
        },
        _drawPoint(point) {
            let databaseConstraintLineButton = document.createElement('database-constraint-line-button');
            databaseConstraintLineButton.translate = {
                x: point.x,
                y: point.y
            };
            databaseConstraintLineButton.new = false;
            Polymer.dom(this.root).appendChild(databaseConstraintLineButton);

            this._points.push(databaseConstraintLineButton);
        },

        removePoint(point) {
            let index = this._points.indexOf(point);

            if (index > -1) {
                this._points.splice(index, 1);
                point.remove();
            }

            this.refreshPath();
        },
        addPoint(point) {
            this._points.splice(point.index, 0, point);
            this.refresh();
        },

        select() {
            this.selected = true;
        },
        deselect() {
            this.selected = false;
        },
        highlight() {
            this.highlighted = true;
        },
        dehighlight() {
            if (!this._tracking && !this._table.table.selected && !this._rTable.table.selected) {
                this.highlighted = false;
            }
        },
        switchConnector(table) {
            if (table === "table") {
                this._table.connector = this._table.connector === "left" ? "right" : "left";
            } else {
                this._rTable.connector = this._rTable.connector === "left" ? "right" : "left";
            }
            this.refresh();
            // todo
//            this.fireUpdateConstraint();
        },
        registerColumn(columns) {
            columns.forEach(function(column) {
                this.constraint.columns.forEach(function(constraintColumn) {
                    let id = this.constraint.schema + "_" + this.constraint.table + "_" + constraintColumn;
                    if (id === column.id) {
                        this._table.columns.push(column);
                    }
                }, this);

                this.constraint.rcolumns.forEach(function(rConstraintColumn) {
                    let id = this.constraint.rschema + "_" + this.constraint.rtable + "_" + rConstraintColumn;
                    if (id === column.id) {
                        this._rTable.columns.push(column);
                    }
                }, this);
            }, this);

            /** save columns positions in the table **/
            this._table.column_pos = this._table.columns[0].getPosition();
            this._table.column_height = this._table.columns[0].offsetHeight / 2;
            if (this._rTable.columns.length > 0) {
                this._rTable.column_pos = this._rTable.columns[0].getPosition();
                this._rTable.column_height = this._rTable.columns[0].offsetHeight / 2;
            }
        },

        trackStart() {
            this._tracking = true;
            this.highlight();
        },
        trackEnd() {
            this._tracking = false;
        },

        fireUpdateConstraint() {
            let positions = [];
            this._points.forEach(function(point) {
                positions.push({
                    x: point.translate.x,
                    y: point.translate.y
                });
            });
            this._table.table.getSchema()._visualizer.fireUpdateConstraint(this.constraint.id, this._table.connector === 'right', this._rTable.connector === 'right', positions);
        }
    });
</script>
</html>
